
//__________________________________________________________________________________
//__________________________________________________________________________________
//
//						MISCELLANEOUS FUNCTIONS
//__________________________________________________________________________________
//__________________________________________________________________________________


//JOINABLE NPCS ARRAY MACRO__________________________________________________________
//
DEFINE_ACTION_MACRO JOINABLE_NPC_ARRAYS BEGIN
	//PDIALOG.2DA exists in all games
	ACTION_DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~PDIALOG~ => ~~ END
	//Check PDIALOG.2DA file variants referenced in CAMPAIGN.2DA
	ACTION_IF FILE_EXISTS_IN_GAME ~CAMPAIGN.2DA~ BEGIN
		COPY_EXISTING ~CAMPAIGN.2DA~ ~CAMPAIGN.2DA~
			COUNT_2DA_ROWS 32 "cntrow"
			FOR (i = 0; i < cntrow; i = i + 1) BEGIN
				READ_2DA_ENTRY i 11 32 file
				TO_UPPER file
				DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_2da BEGIN ~%file%~ => ~~ END
			END
		BUT_ONLY
	END
	//Generate array with joinable NPC DV
	ACTION_PHP_EACH JOINABLE_NPC_ARRAY_2da AS file => ~~ BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME ~%file%.2da~ BEGIN
			COPY_EXISTING ~%file%.2da~ ~override~
				COUNT_2DA_ROWS 3 "cntrow"
				FOR (i = 1; i < cntrow; i = i + 1) BEGIN
					READ_2DA_ENTRY i 0 3 "dv"
					TO_UPPER dv
					DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY_dv BEGIN ~%dv%~ => ~~ END
				END
			BUT_ONLY
		END
	END
	//Generate array with joinable NPC cre files
	COPY_EXISTING_REGEXP GLOB ~.+\.CRE~ ~override~
		READ_ASCII DEATHVAR "dv" (32) NULL
		TO_UPPER dv
		PATCH_IF VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%dv%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%dv%~ END
		END
		PATCH_IF NOT VARIABLE_IS_SET $JOINABLE_NPC_ARRAY_dv(~%dv%~) BEGIN
			DEFINE_ASSOCIATIVE_ARRAY NON_JOINABLE_NPC_ARRAY BEGIN ~%SOURCE_FILE%~ => ~%dv%~ END
		END
	BUT_ONLY
END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION multiclass_text BEGIN

ACTION_IF (FILE_EXISTS_IN_GAME ~clastext.2da~) BEGIN
  	COPY_EXISTING ~clastext.2da~ ~override~
		COUNT_2DA_COLS cols
		READ_2DA_ENTRIES_NOW rows cols  
		FOR (row = 1; row < rows; ++row) BEGIN
		  READ_2DA_ENTRY_FORMER rows row 0 ~text~
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC~ BEGIN
		    SET c_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_CLERIC~ BEGIN
		    SET fc_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_MAGE~ BEGIN
		    SET cm_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_THIEF~ BEGIN
		    SET ct_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_RANGER~ BEGIN
		    SET cr_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_DRUID~ BEGIN
		    SET fd_row = %row%
		  END
		END
		SET_2DA_ENTRY %c_row% 3 cols RESOLVE_STR_REF (@10001)
		SET_2DA_ENTRY %c_row% 5 cols RESOLVE_STR_REF (@10002)
		SET_2DA_ENTRY %c_row% 4 cols RESOLVE_STR_REF (@10005)
		SET_2DA_ENTRY %fc_row% 3 cols RESOLVE_STR_REF (@10011)
		SET_2DA_ENTRY %fc_row% 5 cols RESOLVE_STR_REF (@10012)
		SET_2DA_ENTRY %fc_row% 4 cols RESOLVE_STR_REF (@10015)
		SET_2DA_ENTRY %cm_row% 3 cols RESOLVE_STR_REF (@10021)
		SET_2DA_ENTRY %cm_row% 5 cols RESOLVE_STR_REF (@10022)
		SET_2DA_ENTRY %cm_row% 4 cols RESOLVE_STR_REF (@10025)
		SET_2DA_ENTRY %ct_row% 3 cols RESOLVE_STR_REF (@10031)
		SET_2DA_ENTRY %ct_row% 5 cols RESOLVE_STR_REF (@10032)
		SET_2DA_ENTRY %ct_row% 4 cols RESOLVE_STR_REF (@10035)
		SET_2DA_ENTRY %cr_row% 3 cols RESOLVE_STR_REF (@10041)
		SET_2DA_ENTRY %cr_row% 5 cols RESOLVE_STR_REF (@10042)
		SET_2DA_ENTRY %cr_row% 4 cols RESOLVE_STR_REF (@10045)
		SET_2DA_ENTRY %fd_row% 3 cols RESOLVE_STR_REF (@10051)
		SET_2DA_ENTRY %fd_row% 5 cols RESOLVE_STR_REF (@10052)
		SET_2DA_ENTRY %fd_row% 4 cols RESOLVE_STR_REF (@10055)
  	BUT_ONLY
END
ACTION_IF (FILE_EXISTS_IN_GAME ~sodcltxt.2da~) BEGIN
  	COPY_EXISTING ~sodcltxt.2da~ ~override~
		COUNT_2DA_COLS cols // amount of columns
		READ_2DA_ENTRIES_NOW rows cols // read all file into memory  
		FOR (row = 1; row < rows; ++row) BEGIN // iterate over rows
		  READ_2DA_ENTRY_FORMER rows row 0 ~text~ // read column value
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC~ BEGIN
		    SET c_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_CLERIC~ BEGIN
		    SET fc_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_MAGE~ BEGIN
		    SET cm_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_THIEF~ BEGIN
		    SET ct_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~CLERIC_RANGER~ BEGIN
		    SET cr_row = %row%
		  END
		  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~FIGHTER_DRUID~ BEGIN
		    SET fd_row = %row%
		  END
		END
		SET_2DA_ENTRY %c_row% 3 cols RESOLVE_STR_REF (@10001)
		SET_2DA_ENTRY %c_row% 5 cols RESOLVE_STR_REF (@10002)
		SET_2DA_ENTRY %c_row% 4 cols RESOLVE_STR_REF (@10005)
		SET_2DA_ENTRY %fc_row% 3 cols RESOLVE_STR_REF (@10011)
		SET_2DA_ENTRY %fc_row% 5 cols RESOLVE_STR_REF (@10012)
		SET_2DA_ENTRY %fc_row% 4 cols RESOLVE_STR_REF (@10015)
		SET_2DA_ENTRY %cm_row% 3 cols RESOLVE_STR_REF (@10021)
		SET_2DA_ENTRY %cm_row% 5 cols RESOLVE_STR_REF (@10022)
		SET_2DA_ENTRY %cm_row% 4 cols RESOLVE_STR_REF (@10025)
		SET_2DA_ENTRY %ct_row% 3 cols RESOLVE_STR_REF (@10031)
		SET_2DA_ENTRY %ct_row% 5 cols RESOLVE_STR_REF (@10032)
		SET_2DA_ENTRY %ct_row% 4 cols RESOLVE_STR_REF (@10035)
		SET_2DA_ENTRY %cr_row% 3 cols RESOLVE_STR_REF (@10041)
		SET_2DA_ENTRY %cr_row% 5 cols RESOLVE_STR_REF (@10042)
		SET_2DA_ENTRY %cr_row% 4 cols RESOLVE_STR_REF (@10045)
		SET_2DA_ENTRY %fd_row% 3 cols RESOLVE_STR_REF (@10051)
		SET_2DA_ENTRY %fd_row% 5 cols RESOLVE_STR_REF (@10052)
		SET_2DA_ENTRY %fd_row% 4 cols RESOLVE_STR_REF (@10055)
  	BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION enable_multiclasses BEGIN

ACTION_IF FILE_EXISTS_IN_GAME ~CLSRCREQ.2da~ BEGIN
 COPY_EXISTING ~clsrcreq.2da~ ~override~
  COUNT_2DA_ROWS 8 rows
  FOR (row = 0 ; row < rows ; ++row) BEGIN
    READ_2DA_ENTRY row 0 8 entry
    PATCH_IF (("%entry%" STRING_COMPARE_CASE "FIGHTER_CLERIC"      = 0) OR
              ("%entry%" STRING_COMPARE_CASE "CLERIC_THIEF"        = 0)) BEGIN // cleric/thief, fighter/cleric
      SET_2DA_ENTRY  row 1 8 1
      SET_2DA_ENTRY  row 2 8 1
      SET_2DA_ENTRY  row 3 8 1
      SET_2DA_ENTRY  row 4 8 1
      SET_2DA_ENTRY  row 5 8 1
      SET_2DA_ENTRY  row 6 8 1
      SET_2DA_ENTRY  row 7 8 1
    END
    PATCH_IF ("%entry%" STRING_COMPARE_CASE "CLERIC_MAGE"         = 0) BEGIN // cleric/mage
      SET_2DA_ENTRY  row 1 8 1
      SET_2DA_ENTRY  row 2 8 1
      SET_2DA_ENTRY  row 3 8 1
      SET_2DA_ENTRY  row 6 8 1
    END
    PATCH_IF ("%entry%" STRING_COMPARE_CASE "CLERIC_RANGER"       = 0) BEGIN // cleric/ranger
      SET_2DA_ENTRY  row 1 8 1
      SET_2DA_ENTRY  row 2 8 1
      SET_2DA_ENTRY  row 3 8 1
    END
    PATCH_IF (("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE"        = 0) OR
              ("%entry%" STRING_COMPARE_CASE "FIGHTER_THIEF"       = 0) OR
              ("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE_THIEF"  = 0) OR
              ("%entry%" STRING_COMPARE_CASE "MAGE_THIEF"          = 0)) BEGIN // other human multiclasses
      SET_2DA_ENTRY  row 1 8 1
    END
    PATCH_IF (("%entry%" STRING_COMPARE_CASE "DRUID"               = 0) OR
    		  ("%entry%" STRING_COMPARE_CASE "FIGHTER_DRUID"       = 0)) BEGIN // druids and mystics
      SET_2DA_ENTRY  row 1 8 1
      SET_2DA_ENTRY  row 2 8 1
      SET_2DA_ENTRY  row 3 8 1
      SET_2DA_ENTRY  row 4 8 1
      SET_2DA_ENTRY  row 5 8 1
      SET_2DA_ENTRY  row 6 8 1
      SET_2DA_ENTRY  row 7 8 1
    END
    PATCH_IF ("%entry%" STRING_COMPARE_CASE "FIGHTER_MAGE_CLERIC" = 0) BEGIN // fighter/mage/cleric
      SET_2DA_ENTRY  row 1 8 0
      SET_2DA_ENTRY  row 2 8 0
      SET_2DA_ENTRY  row 3 8 0
      SET_2DA_ENTRY  row 4 8 0
      SET_2DA_ENTRY  row 5 8 0
      SET_2DA_ENTRY  row 6 8 0
      SET_2DA_ENTRY  row 7 8 0
    END
  END
  PRETTY_PRINT_2DA
 BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION druid_class_text BEGIN

ACTION_IF (FILE_EXISTS_IN_GAME ~clastext.2da~) BEGIN
  COPY_EXISTING ~clastext.2da~ ~override~
	COUNT_2DA_COLS cols 
	READ_2DA_ENTRIES_NOW rows cols 
	FOR (row = 1; row < rows; ++row) BEGIN 
	  READ_2DA_ENTRY_FORMER rows row 0 ~text~ 
	  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~DRUID~ BEGIN
	    SET patch_row = %row%
	  END
	END
	SET_2DA_ENTRY %patch_row% 3 cols RESOLVE_STR_REF (@70001)
	SET_2DA_ENTRY %patch_row% 5 cols RESOLVE_STR_REF (@70002)
	SET_2DA_ENTRY %patch_row% 4 cols RESOLVE_STR_REF (@70003)
  BUT_ONLY
END
ACTION_IF (FILE_EXISTS_IN_GAME ~sodcltxt.2da~) BEGIN
  COPY_EXISTING ~sodcltxt.2da~ ~override~
	COUNT_2DA_COLS cols 
	READ_2DA_ENTRIES_NOW rows cols 
	FOR (row = 1; row < rows; ++row) BEGIN 
	  READ_2DA_ENTRY_FORMER rows row 0 ~text~ 
	  PATCH_IF ~%text%~ STRING_EQUAL_CASE ~DRUID~ BEGIN
	    SET patch_row = %row%
	  END
	END
	SET_2DA_ENTRY %patch_row% 3 cols RESOLVE_STR_REF (@70001)
	SET_2DA_ENTRY %patch_row% 5 cols RESOLVE_STR_REF (@70002)
	SET_2DA_ENTRY %patch_row% 4 cols RESOLVE_STR_REF (@70003)
  BUT_ONLY
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION druid_xp BEGIN

// from BG2Tweaks

COPY_EXISTING ~xplevel.2da~ ~override~
REPLACE_TEXTUALLY
~CLERIC \(.*\)
DRUID \(.*\)~
~CLERIC \1
DRUID  \1~
BUT_ONLY

ACTION_IF FILE_EXISTS_IN_GAME ~lunumab.2da~ THEN BEGIN
  COPY_EXISTING ~lunumab.2da~ ~override~
    READ_2DA_ENTRY  2 1 5 "cleric"   // read trueclass cleric value for initial HLA level
    SET_2DA_ENTRY   6 1 5 "%cleric%" // write trueclass cleric value for initial HLA level into druid slot
    READ_2DA_ENTRY  9 1 5 "f_c"      // read dual f/c value for initial HLA level
    SET_2DA_ENTRY  15 1 5 "%f_c%"    // write dual f/c cleric value for initial HLA level into dual f/d slot
    READ_2DA_ENTRY 22 1 5 "multic"   // read multiclass cleric value for initial HLA level
    SET_2DA_ENTRY  24 1 5 "%multic%" // write multiclass cleric value for initial HLA level into multiclass druid slot
  BUT_ONLY
END

COPY_EXISTING ~mxsplprs.2da~ ~override/mxspldru.2da~

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION paladin_spell_tables BEGIN

  COPY ~faiths_and_powers/spheres/mxsplpal.2da~ ~override~

END // end function


DEFINE_ACTION_FUNCTION ranger_spell_tables BEGIN

  COPY ~faiths_and_powers/spheres/mxsplran.2da~ ~override~

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION shaman_spells BEGIN

// set up spell-learning UI here
INCLUDE ~faiths_and_powers/lib/sequencer_menu_d5.tpa~

LAF CREATE_SEQUENCER_MENU 
  INT_VAR 
	name = RESOLVE_STR_REF (~Spell Selection~)
	tip = RESOLVE_STR_REF (~Spell Selection~)
	desc = RESOLVE_STR_REF (~This ability allows you to learn new spells~)
	class = 2
	maxlevel = 7
	exclude = 0x80000000 
  STR_VAR 
	resref = ~d5msham~
	icon = ~spcl919b~
	title = ~Spell Selection~
	label = ~Select a spell to learn~
	subspell = ~N~
END

ACTION_IF (FILE_EXISTS_IN_GAME ~clabsh01.2da~) BEGIN
  APPEND ~clabsh01.2da~ ~SHMN_LRN    GA_D5MSHAM  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
END
ACTION_IF (FILE_EXISTS_IN_GAME ~clabshgs.2da~) BEGIN
  APPEND ~clabshgs.2da~ ~SHMN_LRN    GA_D5MSHAM  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
END

COPY_EXISTING ~kitlist.2da~ ~override~
  COUNT_2DA_ROWS 9 rows
  FOR (row = 30 ; row < rows ; row = row + 1 ) BEGIN
	READ_2DA_ENTRY row 5 9 kitclab
	READ_2DA_ENTRY row 8 9 kitclass
	PATCH_IF (kitclass = 21) BEGIN
	  PATCH_IF (FILE_EXISTS_IN_GAME ~%kitclab%.2da~) BEGIN
		INNER_ACTION BEGIN
		  APPEND ~%kitclab%.2da~ ~SHMN_LRN    GA_D5MSHAM  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
		END
	  END
	END
//	SPRINT $d5_shaman_clabs ("%modclab%") "%modclass%" END
  END
BUT_ONLY

// need to give d5msham to shamans (isn't that being done just above?)
// ...and the shambarb!
// ...erm, need to *make* the shambarb...

COPY ~faiths_and_powers/kits/incarnates/splshmkn.2da~ ~override~

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION remove_sc_menu_kits BEGIN

//ACTION_FOR_EACH class IN ~C~ ~D~ ~P~ ~R~ /*~FC~ ~FD~ ~CM~ ~CT~ ~CR~*/ BEGIN
  ACTION_FOR_EACH race IN ~D~ ~E~ ~G~ ~H~ ~HE~ ~HL~ ~HO~ BEGIN
	ACTION_IF FILE_EXISTS_IN_GAME ~K_%class%_%race%.2da~ BEGIN
	  COPY_EXISTING ~K_%class%_%race%.2da~ ~override~
		COUNT_2DA_COLS cols
		READ_2DA_ENTRIES_NOW rows cols
		SET rows_removed = 0
		FOR (row = 1; row < rows; ++row) BEGIN
		  READ_2DA_ENTRY_FORMER rows row 1 kit
		  PATCH_IF 
					(%kit% = 0) OR 
		  			(%kit% = 17) OR 
		  			(%kit% = 19) OR 
		  			(%kit% = 20) OR 
		  			(%kit% = 21) OR 
		  			(%kit% = 4) OR 
		  			(%kit% = 5) OR 
		  			(%kit% = 6) BEGIN
			REMOVE_2DA_ROW (row - rows_removed) cols
			SET rows_removed += 1
		  END
		END
	  BUT_ONLY
	END
  END
//END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION more_ranger_alignments BEGIN

ACTION_PHP_EACH d5_fnp_kit_class_access AS kit => class BEGIN
  ACTION_IF (~%class%~ STRING_EQUAL_CASE ~SCOUT~) BEGIN
	COPY_EXISTING ~kitlist.2da~ ~override~
//	  COUNT_2DA_COLS cols
	  READ_2DA_ENTRIES_NOW rows 9
	  FOR (row = 7; row < rows; ++row) BEGIN
		READ_2DA_ENTRY_FORMER rows row 5 ~clab~
		PATCH_IF ~%clab%~ STRING_EQUAL_CASE ~%kit%~ BEGIN
		  SET kit_index = %row%
		  READ_2DA_ENTRY_FORMER rows kit_index 1 kit_label
		END
	  END
	BUT_ONLY
	APPEND ~fallen.2da~ ~%kit_label%%TAB%0~
	COPY_EXISTING ~alignmnt.2da~ ~override~
	  COUNT_2DA_COLS num_cols
	  READ_2DA_ENTRIES_NOW ~r2en_align~ num_cols
	  FOR (row = 3; row < r2en_align; row += 1) BEGIN
		READ_2DA_ENTRY_FORMER ~r2en_align~ row 0 align_name
		PATCH_IF (~%align_name%~ STRING_EQUAL_CASE ~%kit_label%~) BEGIN
		  FOR (col = 1; col < num_cols; col += 1) BEGIN
			SET_2DA_ENTRY_LATER ~s2el_align~ row col 1 
		  END
		END
	  END
	  SET_2DA_ENTRIES_NOW ~s2el_align~ num_cols
	BUT_ONLY
  END
END

END // end function


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION disable_dual_classing BEGIN

LAM d5_dual_classing

ACTION_IF (%d5_dual_class% = 0) BEGIN
  COPY_EXISTING ~dualclas.2da~ ~override~
	COUNT_2DA_COLS cols
	COUNT_2DA_ROWS cols rows
	FOR (row = 0; row < (rows - 1); ++row) BEGIN
	  SET_2DA_ENTRY row 2 cols 0
	  SET_2DA_ENTRY row 6 cols 0
	END
	PRETTY_PRINT_2DA
  BUT_ONLY
END

END // end function


//___________________________________________________________________________________
//___________________________________________________________________________________


//REMOVE BLANK LINES MACRO_____________________________________________________________
//
DEFINE_PATCH_MACRO ~remove_blank_lines~ BEGIN
	SET "size" = (SOURCE_SIZE - 1)
	READ_BYTE ("%size%") "eof"
	WHILE ((%size% > 0) AND (("%eof%" = 0x0a) OR ("%eof%" = 0x0d))) BEGIN // removes any empty lines at the end of the file
		DELETE_BYTES "%size%" 0x01
		SET "size" = ("%size%" - 1)
		READ_BYTE ("%size%") "eof"
	END
END


//__________________________________________________________________________________
//__________________________________________________________________________________


// converts spell to innate and lowers casting time by two

DEFINE_PATCH_MACRO ~spell_to_innate~ BEGIN

  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0
  READ_ASCII (abil_off + 0x04) bam (8) // reads the bam filename from ability
  WRITE_SHORT 0x1C 4                         // sets spell type to innate (4)
  WRITE_LONG  0x34 1                         // sets spell level to 1 to avoid scripting issues
  WRITE_ASCIIE 0x3A "%bam%" #8      // writes the bam filename from abilities to spell icon
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) 4 // changes ability icon location to innate (4)
    READ_SHORT  (abil_off + 0x12 + (0x28 * index)) speed // reads casting speed
    PATCH_IF (speed > 3) BEGIN
      WRITE_SHORT  (abil_off + 0x12 + (0x28 * index)) (speed - 2) // reduces casting speed
    END ELSE BEGIN
      WRITE_SHORT  (abil_off + 0x12 + (0x28 * index)) 0 // makes instant
    END
  END

END


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION 2DA_MISSING_COLS
	INT_VAR
	cols = 0 //minimum amount of columns that should have values (if not set function will automatically read max number of columns in file)
	STR_VAR
	2da = ~~ //2da file that should be patched, e.g. kitlist
	entry = ~~ //what entry should be set in missing columns (if not set function will automatically read default entry from loaded 2da, e.g. *)
BEGIN
	ACTION_IF ~%2da%~ STR_EQ ~~ BEGIN
		FAIL ~2DA_MISSING_COLS: %2da% STR_VAR not set~
	END
	COPY_EXISTING ~%2da%.2da~ ~override~
		PRETTY_PRINT_2DA
		PATCH_IF ~%entry%~ STR_EQ ~~ BEGIN
			READ_2DA_ENTRY 1 0 1 "entry"
		END
		PATCH_IF cols = 0 BEGIN
			COUNT_2DA_COLS "cols"
		END
		SET cnt = 0
		REPLACE_EVALUATE ~^\(.+\)$~ BEGIN
			PATCH_IF cnt >= 3 BEGIN
				INNER_PATCH_SAVE MATCH1 ~%MATCH1%~ BEGIN
					COUNT_REGEXP_INSTANCES ~ +~ num_matches
					WHILE (num_matches < (cols - 1)) BEGIN
						REPLACE_TEXTUALLY ~$~ ~ %entry%~
						SET num_matches = num_matches + 1
					END
				END
			END ELSE BEGIN
				SET cnt = cnt + 1
			END
		END ~%MATCH1%~
		PRETTY_PRINT_2DA
	BUT_ONLY
END

DEFINE_PATCH_FUNCTION 2DA_MISSING_COLS
	INT_VAR
	cols = 0 //minimum amount of columns that should have values (if not set function will automatically read max number of columns in file)
	STR_VAR
	entry = ~~ //what entry should be used in missing columns (if not set function will automatically read default entry from loaded 2da, e.g. *)
BEGIN
	PRETTY_PRINT_2DA
	PATCH_IF ~%entry%~ STR_EQ ~~ BEGIN
		READ_2DA_ENTRY 1 0 1 "entry"
	END
	PATCH_IF cols = 0 BEGIN
		COUNT_2DA_COLS "cols"
	END
	SET cnt = 0
	REPLACE_EVALUATE ~^\(.+\)$~ BEGIN
		PATCH_IF cnt >= 3 BEGIN
			INNER_PATCH_SAVE MATCH1 ~%MATCH1%~ BEGIN
				COUNT_REGEXP_INSTANCES ~ +~ num_matches
				WHILE (num_matches < (cols - 1)) BEGIN
					REPLACE_TEXTUALLY ~$~ ~ %entry%~
					SET num_matches = num_matches + 1
				END
			END
		END ELSE BEGIN
			SET cnt = cnt + 1
		END
	END ~%MATCH1%~
	PRETTY_PRINT_2DA
END


//__________________________________________________________________________________
//__________________________________________________________________________________


//GENERATE NEW SPECIFICS MACRO______________________________________________________
//
DEFINE_ACTION_FUNCTION d5_resolve_specific INT_VAR index=0 delete=0 STR_VAR new_specific_id = ~blah~ RET new_specific_ind BEGIN
 OUTER_SET min_new=1
 COPY_EXISTING ~specific.ids~ override
  new_specific_ind=0
  found=0
  READ_2DA_ENTRIES_NOW stats 2
  FOR (row=1;row<stats;row+=1) BEGIN
    READ_2DA_ENTRY_FORMER stats row 0 ind
    READ_2DA_ENTRY_FORMER stats row 1 str
    SET $stat("%row%") = ind
    PATCH_IF index BEGIN
      PATCH_IF ind=index BEGIN
        REMOVE_2DA_ROW row 2
        found=1
        PATCH_IF delete=0 BEGIN
          INSERT_2DA_ROW row 2 ~%index% %new_specific_id%~
        END
        row=stats
      END
    END ELSE BEGIN
      PATCH_IF ~%str%~ STRING_EQUAL_CASE ~%new_specific_id%~ BEGIN
        new_specific_ind=ind
        found=1
     /* row=stats */ // don't stop looking, the same ID may be assigned to a greater index, which takes priority when compiling
      END
    END
   END
   PATCH_IF found=0 BEGIN
    new_specific_ind=min_new
    PHP_EACH stat AS row => ind BEGIN
      PATCH_IF found=0 && (row+1 < stats) BEGIN // not at the end of file
        next_row = row+1
        next_ind = EVAL $stat("%next_row%")
        PATCH_IF index BEGIN
          PATCH_IF index<next_ind && index>ind BEGIN
            INSERT_2DA_ROW next_row 2 ~%index% %new_specific_id%~
            found=1
          END
        END ELSE BEGIN
          PATCH_IF new_specific_ind<next_ind BEGIN
            PATCH_IF ind<new_specific_ind BEGIN
              INSERT_2DA_ROW next_row 2 ~%new_specific_ind% %new_specific_id%~
              found=1
            END ELSE BEGIN
              new_specific_ind+=1
              PATCH_IF new_specific_ind<next_ind BEGIN
                INSERT_2DA_ROW next_row 2 ~%new_specific_ind% %new_specific_id%~
                found=1
              END
            END
          END
        END
      END ELSE BEGIN // at the end of file
        PATCH_IF found=0 BEGIN
          PATCH_IF index BEGIN
            INSERT_2DA_ROW stats 2 ~%index% %new_specific_id%~
          END ELSE BEGIN
            PATCH_IF new_specific_ind>ind BEGIN
              INSERT_2DA_ROW stats 2 ~%new_specific_ind% %new_specific_id%~
            END ELSE BEGIN
              new_specific_ind+=1
              INSERT_2DA_ROW stats 2 ~%new_specific_ind% %new_specific_id%~
            END
          END
        END
      END
    END // PHP_EACH
  END
END


//__________________________________________________________________________________
//__________________________________________________________________________________


//UMD FOR CLERICS___________________________________________________________________
//

DEFINE_ACTION_FUNCTION use_magical_devices BEGIN

 LAF d5_resolve_specific STR_VAR new_specific_id = ~D5_NO_UMD~ RET new_specific_ind END

 OUTER_SET no_umd_specific = %new_specific_ind%

 COPY ~%MOD_FOLDER%/kits/misc/d5_umd.spl~ ~override~
	LPF ADD_SPELL_EFFECT INT_VAR opcode = 206 target = 1 parameter1 = (0 - 1) timing = 9 STR_VAR resource = ~d5_numd~ END

 COPY ~%MOD_FOLDER%/kits/misc/d5_numd.spl~ ~override~
  LPF ALTER_EFFECT INT_VAR match_opcode = 177 STR_VAR resource = ~d5_numd~ END
// add .eff setting local variable
  LPF CLONE_EFFECT INT_VAR match_opcode = 177 STR_VAR resource = ~d5numdlv~ END

 COPY ~%MOD_FOLDER%/kits/misc/D5_NUMD.eff~ ~override~
  WRITE_LONG 0x1c %no_umd_specific%
  WRITE_LONG 0x90 1
  WRITE_EVALUATED_ASCII 0x94 ~D5_NUMD~ #8

// make an .eff to set D5NOUMD local variable
 CREATE EFF ~d5numdlv~
	WRITE_LONG 0x10 309
	WRITE_LONG 0x14 1
	WRITE_LONG 0x1c 1
	WRITE_LONG 0x20 0
	WRITE_LONG 0x24 9
	WRITE_LONG 0x28 0
	WRITE_SHORT 0x2c 100
	WRITE_ASCII 0x30 ~D5NOUMD~ #8

 OUTER_SET scroll_count = 0
 OUTER_SPRINT $use_scrolls(~%scroll_count%~) ~scroll~
 COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~
  READ_BYTE     0x2f current ELSE 0
  READ_BYTE     0x2b current2 ELSE 0
  READ_LONG 0x64 headoffset  ELSE 0
  READ_SHORT 0x68 headcount  ELSE 0
  READ_LONG 0x6a effectsoffset  ELSE 0
  haslearn = 0
  hascast = 0
//	  PATCH_IF (headcount = 2) BEGIN
    FOR (headcyc = 0; headcyc < headcount ; headcyc = headcyc + 1) BEGIN
      thishead = 0
      READ_SHORT (headoffset + (headcyc * 0x38) + 0x1e) effcount  ELSE 0
      READ_SHORT (headoffset + (headcyc * 0x38) + 0x20) effectsindex  ELSE 0
      FOR (effcyc = 0; effcyc < effcount; effcyc = effcyc + 1) BEGIN
        READ_SHORT (effectsoffset + (effectsindex + effcyc)* 0x30) opcode ELSE 0
        PATCH_IF (opcode = 0x93) AND (thishead = 0) BEGIN
          READ_ASCII (effectsoffset + 0x14 + (effectsindex + effcyc)* 0x30) resref_learn  ELSE 0
          INNER_PATCH_FILE ~%resref_learn%.spl~ BEGIN
            READ_SHORT 0x1c type
          END
          PATCH_IF (type = 1) BEGIN // spell scroll
            thishead = 1
            haslearn = 1
          END
        END // PATCH_IF... (opcode = learn spell)
        PATCH_IF ((opcode = 0x92) OR (opcode = 0x94)) AND (thishead = 0) BEGIN
          READ_ASCII (effectsoffset + 0x14 + (effectsindex + effcyc)* 0x30) resref_cast  ELSE 0
          INNER_PATCH_FILE ~%resref_cast%.spl~ BEGIN
            READ_SHORT 0x1c type
          END
          PATCH_IF (type = 1) OR (type = 2) BEGIN // spell scroll
            thishead = 1
            hascast = 1
          END
        END // PATCH_IF (opcode = cast spell)
      END // FOR... effect_cycle
    END // FOR... header cycle
//  END // PATCH_IF... have exactly 2 headers
  PATCH_IF (haslearn = 1) AND (hascast = 1) /*AND (~%resref_cast%~ STRING_EQUAL_CASE ~%resref_learn%~) */BEGIN
	SPRINT $use_scrolls(~%scroll_count%~) ~%SOURCE_RES%~
	SET ++scroll_count
  END
 BUT_ONLY
 ACTION_PHP_EACH use_scrolls AS num => scroll BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%scroll%.itm~ BEGIN
//	PRINT ~%scroll% is a wizard scroll~
	COPY_EXISTING ~%scroll%.itm~ ~override~
	  WRITE_BYTE 0x1e (THIS BAND 0b01111111)
	  WRITE_BYTE 0x1f (THIS BAND 0b10111001)
	  PATCH_IF !(FILE_EXISTS_IN_GAME ~d5_umd.d5~) BEGIN
		LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 319 target = 1 parameter2 = 6 parameter1 = %no_umd_specific% timing = 2 END
	  END
	BUT_ONLY
  END
 END
 COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~
  READ_SHORT	0x1c item_type
  PATCH_IF (item_type = 35) BEGIN
	READ_BYTE 0x1e cleric_use
	READ_BYTE 0x1e mcleric_use
	PATCH_IF (%cleric_use% BAND 0b10000000) = 0b10000000 BEGIN
	  WRITE_BYTE 0x1e (THIS BAND 0b01111111)
	  WRITE_BYTE 0x1f (THIS BAND 0b10111001)
	  PATCH_IF !(FILE_EXISTS_IN_GAME ~d5_umd.d5~) BEGIN
		LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 319 target = 1 parameter2 = 6 parameter1 = %no_umd_specific% timing = 2 END
	  END
	END
  END
 BUT_ONLY

 ACTION_IF GAME_INCLUDES ~sod~ BEGIN
  COPY_EXISTING dplayer2.bcs override
	DECOMPILE_AND_PATCH BEGIN
	  REPLACE_TEXTUALLY ~THEN[%WNL%%LNL%%MNL%%TAB% ]+RESPONSE[%TAB% ]+#100[%WNL%%LNL%%MNL%%TAB% ]+ChangeSpecifics(Myself,\(1\|NORMAL\))~
    ~
  !Specifics(Myself,D5_NO_UMD)
  Switch("D5NOUMD","locals")
THEN
  RESPONSE #0
    ChangeSpecifics(Myself,NORMAL)
    SetGlobal("bd_joined","locals",0)
    SetGlobal("bd_npc_camp","locals",0)
  RESPONSE #1
    ChangeSpecifics(Myself,D5_NO_UMD)~
	END
  BUT_ONLY
 END

 COPY ~%MOD_FOLDER%/lib/markers/d5_marker.d5~ ~override/d5_umd.d5~

END	//	end umd setup


//__________________________________________________________________________________
//__________________________________________________________________________________


DEFINE_ACTION_FUNCTION cleric_clabs_umd BEGIN

 ACTION_IF !(FILE_EXISTS_IN_GAME ~d5_cleric_umd.d5~) BEGIN

  APPEND ~clabma01.2da~ ~UMD         AP_D5_UMD   ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
	UNLESS ~AP_D5_UMD~
	IF_EXISTS

  APPEND ~clabpr01.2da~ ~UMD         AP_D5_NUMD  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
	UNLESS ~AP_D5_NUMD~

  COPY_EXISTING ~kitlist.2da~ ~override~
	COUNT_2DA_ROWS 9 rows
	FOR ( row = 2 ; row < rows ; ++row ) BEGIN
	  READ_2DA_ENTRY row 5 9 clab
	  READ_2DA_ENTRY row 8 9 class
	  PATCH_IF (class = 3) BEGIN
		INNER_ACTION BEGIN
		  ACTION_IF (FILE_EXISTS_IN_GAME ~%clab%.2da~) && !(FILE_CONTAINS_EVALUATED (~%clab%.2da~ ~AP_D5_UMD~)) BEGIN
			APPEND ~%clab%.2da~ ~UMD         AP_D5_NUMD  ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
			  UNLESS ~AP_D5_NUMD~
		  END
		END
	  END
	  PATCH_IF (class = 1) BEGIN
		INNER_ACTION BEGIN
		  ACTION_IF (FILE_EXISTS_IN_GAME ~%clab%.2da~) BEGIN
			APPEND ~%clab%.2da~ ~UMD         AP_D5_UMD   ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****    ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        ****        **** ~
			  UNLESS ~AP_D5_UMD~
		  END
		END
	  END
	END
  BUT_ONLY

  LAM JOINABLE_NPC_ARRAYS

  ACTION_PHP_EACH NON_JOINABLE_NPC_ARRAY AS cre => stuff BEGIN
	COPY_EXISTING ~%cre%~ ~override~
	  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
		READ_BYTE 0x278 class
		PATCH_IF (class = 14) BEGIN
		  LPF ADD_CRE_EFFECT INT_VAR opcode=206 target=1 timing=9 parameter1=(0 - 1) STR_VAR resource=~d5_numd~ END
		END
	  END
	BUT_ONLY
  END

  COPY ~%MOD_FOLDER%/lib/markers/d5_marker.d5~ ~override/d5_cleric_umd.d5~

 END
 
END	//	end cleric umd function


//__________________________________________________________________________________
//__________________________________________________________________________________


